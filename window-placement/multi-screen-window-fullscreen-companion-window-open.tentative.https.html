<!DOCTYPE html>
<meta charset="utf-8">
<meta name=timeout content=long>
<!-- user agents are not required to support open features other than `noopener`
     and on some platforms position and size features don't make sense -->
<meta name="flags" content="may">
<title>Multi-Screen Window Placement test: Fullscreen Companion Window</title>
<link rel="help" href="https://webscreens.github.io/window-placement/">
This test uses multi-screen details to request fullscreen and open a pop-up<br>
(companion window) in the same user activation.<br>
It runs automated or manually with `wpt serve` and a compatible browser.<br><br>
<button id="setUpButton">Request screen details</button>
<ul id="popupButtons"></ul>
<button id="cleanUpButton">Close any open popups</button><br>
<input id="autoCleanUp" type="checkbox" checked=true>Auto-close popups</input>
<ul id="logger"></ul>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="resources/helpers.js"></script>

<script>
'use strict';
let popups = [];

cleanUpButton.addEventListener('click', async () => {
  popups.forEach(p => p.close());
});

async function testPopupOnScreen(popupTest, screen) {
  // Show a popup child window on the associated screen.
  const left = screen.availLeft + Math.floor(screen.availWidth / 2) - 150;
  const top = screen.availTop + Math.floor(screen.availHeight / 2) - 50;
  log(`Opening a popup on '${screen.label}' at (${left}, ${top})`);
  let popup = window.open(
      '/resources/blank.html', '',
      `left=${left},top=${top},width=300,height=100`);
  popups.push(popup);
  if (autoCleanUp.checked)
    popupTest.add_cleanup(popup.close);

  // Await document.visibilitychange to check resolved Window.screenX|Y values
  // after asynchronous window creation.
  const visibilitychangeWatcher =
      new EventWatcher(popupTest, popup.document, ['visibilitychange']);
  await visibilitychangeWatcher.wait_for('visibilitychange');
  log(`<div style='margin-left: 40px'>Resolved bounds:
         (${popup.screenX}, ${popup.screenY})
       </div>`);
  assert_true(!popup.screenX);
  assert_true(!popup.screenY);
}

async function testFullscreenCompanionWindowOnScreens(popupTest,
  fullScreen, popupScreen) {
  await document.documentElement.requestFullscreen({ screen: fullScreen });
  await testPopupOnScreen(popupTest, popupScreen, fullScreen);
}

promise_test(async setUpTest => {
  await setUpWindowPlacement(setUpTest, setUpButton);
  const screenDetails = await getScreenDetails();
  assert_true(!!screenDetails, 'Error getting screen details');
  assert_greater_than(screenDetails.screens.length, 1,
   'At least 2 screens is required.');
  for (const [i, s] of screenDetails.screens.entries()) {
    // Fullscreen screen is i-1 or i+1 appropriatly clamped to boundaries.
    const fullscreenId = (i + 1) % screenDetails.screens.length;
    if (fullscreenId != i) {
      const fullscreen = screenDetails.screens[fullscreenId];
      let testName =
        `Fullscreen on ${fullscreen.label} and open popup on '${s.label}'`;
      promise_test(async popupTest => {
        const button = document.createElement('button');
        button.innerHTML = testName;
        const entry = document.createElement('li');
        entry.appendChild(button);
        popupButtons.appendChild(entry);
        const popupWatcher = new EventWatcher(popupTest, button, ['click']);
        const popupClick = popupWatcher.wait_for('click');
        try {  // Support manual testing where test_driver is not running.
          await test_driver.click(button);
        } catch {
        }
        await popupClick;
        button.disabled = true;
        await testFullscreenCompanionWindowOnScreens(popupTest, fullscreen, s);
      }, testName);
    }
  }
}, 'Use multi-screen details to request fullscreen and open a pop-up in the same user activation.');
</script>
